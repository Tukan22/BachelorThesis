n<-length(gamma_data)
if(param<=0){return(NA)}
return((n*log(param)-param*sum(gamma_data)))
}
mleb<-maxLik(logLikFunb, start = c(theta=1))
summary(mleb)
waldtest(mle, mleb)
lrtest(mle,mleb)
anova(mle, mleb, test="Rao")
library("lmtest")
library("maxLik")
library("car")
load("gamma_data.Rdata")
gamma_data
library(gamma_data)
library("gamma")
library("gamma_data")
print("Hello World!")
install.packages("ggplot2")
library(p, character.only=TRUE)
for (p in packages){
library(p, character.only=TRUE)
}
packages = c("ggplot2", "gridExtra", "aod", "sandwich", "arm", "lmtest", "ggpubr")
for (p in packages){
library(p, character.only=TRUE)
}
library(ggplot2)
library(ggplot2)
library(gridExtra)
library(aod)
install.package("IRkernel")
install.packages("IRkernel")
install.packages("ggplot2")
library(aod)
library(ggplot2)
R.version
library(rvest)
install.packages("rvest")
library(rvest)
url <- "https://www.seznam.cz/"
webpage <- read_html(url)
html_text(webpage)
?rnorm
help(rnorm)
eps = rnorm(length, mean, std)
set.seed(42)
mean = 0
std = 3
length = 500
p_0 = 0
?rnorm
help(rnorm)
eps = rnorm(length, mean, std)
plot(eps)
plot(eps)
plot(x = 1, y = 1)
par("mar")
par(mar=c(1,1,1,1))
plot(x = 1, y = 1)
plot(x = 1, y = 1)
par(mar=c(1,1,1,1))
plot(x = 1, y = 1)
plot(eps)
library(forecast)
install.packages(forecast)
install.packages("forecast")
library(forecast)
set.seed(42)
mean_eps = 0
std_eps = 3
mean_nu = 0
std_nu = 1
p_0 = 0
r_0 = 0
eps_0 = 0
#nu_0 = 0
e_0 = 0
length = 500
realisations = 1000
p <- data.frame(matrix(ncol = realisations, nrow = length))
r <- data.frame(matrix(ncol = realisations, nrow = length))
e <- data.frame(matrix(ncol = realisations, nrow = length))
p[1,] = p_0
r[1,] = r_0
eps = data.frame(matrix(rnorm(length*realisations, mean_eps, std_eps), ncol = realisations, nrow = length))
eps[1,] = eps_0
nu = matrix(rnorm(length*realisations, mean_nu, std_nu), ncol = realisations, nrow = length)
nu[1,] = nu_0
nu_0 = 0
eps = data.frame(matrix(rnorm(length*realisations, mean_eps, std_eps), ncol = realisations, nrow = length))
eps[1,] = eps_0
nu = matrix(rnorm(length*realisations, mean_nu, std_nu), ncol = realisations, nrow = length)
nu[1,] = nu_0
e <- matrix(rep(0, times = realisations*length), ncol = realisations, nrow = length)
for(i in 2:length){
p[i,] = p[i-1,] + eps[i,] + eps[i-1,]
e[i,] = -e[i-1,] + nu[i,]
r[i,] = r[i-1,] + e[i,]
}
plot.ts(p[,1], ylim = c(min(p),max(p)))
for(j in 2:realisations){
lines(p[,j], col = colors()[j])
}
plot.ts(p[,1], ylim = c(min(p),max(p)))
min(p)
View(p)
sum(is.na(p))
sum(is.na(r))
sum(is.na(e))
length = 20
realisations = 10
# IT SHOULD BE POSSIBLE TO VECTORIZE THIS! - OPTIMIZATION !
#  (Create a dataframe of errors instead of a vector for each realization)
for(i in 2:length){
p[i,] = p[i-1,] + eps[i,] + eps[i-1,]
e[i,] = -e[i-1,] + nu[i,]
r[i,] = r[i-1,] + e[i,]
}
length = 20
realisations = 10
p <- data.frame(matrix(ncol = realisations, nrow = length))
r <- data.frame(matrix(ncol = realisations, nrow = length))
e <- data.frame(matrix(ncol = realisations, nrow = length))
p[1,] = p_0
r[1,] = r_0
eps = data.frame(matrix(rnorm(length*realisations, mean_eps, std_eps), ncol = realisations, nrow = length))
eps[1,] = eps_0
nu = matrix(rnorm(length*realisations, mean_nu, std_nu), ncol = realisations, nrow = length)
nu[1,] = nu_0
e <- matrix(rep(0, times = realisations*length), ncol = realisations, nrow = length)
# IT SHOULD BE POSSIBLE TO VECTORIZE THIS! - OPTIMIZATION !
#  (Create a dataframe of errors instead of a vector for each realization)
for(i in 2:length){
p[i,] = p[i-1,] + eps[i,] + eps[i-1,]
e[i,] = -e[i-1,] + nu[i,]
r[i,] = r[i-1,] + e[i,]
}
plot.ts(p[,1], ylim = c(min(p),max(p)))
for(j in 2:realisations){
lines(p[,j], col = colors()[j])
}
plot.ts(r[,1], ylim = c(min(r),max(r)))
for(j in 2:realisations){
lines(r[,j], col = colors()[j])
}
length = 500
realisations = 1000
p <- data.frame(matrix(ncol = realisations, nrow = length))
r <- data.frame(matrix(ncol = realisations, nrow = length))
e <- data.frame(matrix(ncol = realisations, nrow = length))
length = 500
realisations = 100
p <- data.frame(matrix(ncol = realisations, nrow = length))
r <- data.frame(matrix(ncol = realisations, nrow = length))
e <- data.frame(matrix(ncol = realisations, nrow = length))
p[1,] = p_0
r[1,] = r_0
eps = data.frame(matrix(rnorm(length*realisations, mean_eps, std_eps), ncol = realisations, nrow = length))
eps[1,] = eps_0
nu = matrix(rnorm(length*realisations, mean_nu, std_nu), ncol = realisations, nrow = length)
nu[1,] = nu_0
e <- matrix(rep(0, times = realisations*length), ncol = realisations, nrow = length)
#library(data.table)
#p[-1,] = matrix(unlist(shift(p, 1L, type = "lag")), ncol = realisations, nrow = length)[-1,]
#head(eps)[-1,1:2]
#head(matrix(unlist(shift(eps, 1L, type = "lag")), ncol = realisations, nrow = length))[-1,1:2]
# IT SHOULD BE POSSIBLE TO VECTORIZE THIS! - OPTIMIZATION !
#  (Create a dataframe of errors instead of a vector for each realization)
for(i in 2:length){
p[i,] = p[i-1,] + eps[i,] + eps[i-1,]
e[i,] = -e[i-1,] + nu[i,]
r[i,] = r[i-1,] + e[i,]
}
plot.ts(p[,1], ylim = c(min(p),max(p)))
for(j in 2:realisations){
lines(p[,j], col = colors()[j])
}
plot.ts(r[,1], ylim = c(min(r),max(r)))
for(j in 2:realisations){
lines(r[,j], col = colors()[j])
}
diff(r)
head(r)
head(r[,1])
r[200:205,1]
diff(r[,1])
plot(diff(r[,1]), type = 'l')
plot(abs(diff(r[,1]), type = 'l'))
plot(abs(diff(r[,1]), type = 'l'))
plot(abs(diff(r[,1])), type = 'l')
for(i in 2:length){
p[i,] = p[i-1,] + eps[i,] + eps[i-1,]
e[i,] = -e[i-1,] + nu[i,]
r[i,] = 0.5*r[i-1,] + e[i,]
}
plot.ts(p[,1], ylim = c(min(p),max(p)))
for(j in 2:realisations){
lines(p[,j], col = colors()[j])
}
plot.ts(r[,1], ylim = c(min(r),max(r)))
for(j in 2:realisations){
lines(r[,j], col = colors()[j])
}
plot(abs(diff(r[,1])), type = 'l')
diff(r[,1]))
diff(r[,1])
diff(r[,1])<0
plot.ts(r[,1], ylim = c(min(r),max(r)))
for(j in 2:realisations){
lines(r[,j], col = colors()[j])
}
p_0 = 10
r_0 = 10
eps_0 = 0
nu_0 = 0
e_0 = 0
length = 500
realisations = 100
p <- data.frame(matrix(ncol = realisations, nrow = length))
r <- data.frame(matrix(ncol = realisations, nrow = length))
e <- data.frame(matrix(ncol = realisations, nrow = length))
p[1,] = p_0
r[1,] = r_0
eps = data.frame(matrix(rnorm(length*realisations, mean_eps, std_eps), ncol = realisations, nrow = length))
eps[1,] = eps_0
nu = matrix(rnorm(length*realisations, mean_nu, std_nu), ncol = realisations, nrow = length)
nu[1,] = nu_0
e <- matrix(rep(0, times = realisations*length), ncol = realisations, nrow = length)
# IT SHOULD BE POSSIBLE TO VECTORIZE THIS! - OPTIMIZATION !
#  (Create a dataframe of errors instead of a vector for each realization)
for(i in 2:length){
p[i,] = p[i-1,] + eps[i,] + eps[i-1,]
e[i,] = -e[i-1,] + nu[i,]
r[i,] = r[i-1,] + e[i,]
}
plot.ts(p[,1], ylim = c(min(p),max(p)))
for(j in 2:realisations){
lines(p[,j], col = colors()[j])
}
plot.ts(r[,1], ylim = c(min(r),max(r)))
for(j in 2:realisations){
lines(r[,j], col = colors()[j])
}
plot(apply(p, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(r, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(p, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
plot(apply(r, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
plot(apply(r, MARGIN = 1, FUN = var), type = 'l')
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
max(apply(p, MARGIN = 1, FUN = var))
abline(1,2)
abline(2)
abline(36,0)
abline(36*500,0)
abline(,36)
abline(0,36)
library(moments)
install.packages("moments")
library(moments)
set.seed(1234)
kurtosis(rnorm(1000))
hist(apply(r, MARGIN = 1, FUN = mean))
hist(apply(r, MARGIN = 1, FUN = mean), density = T)
plot(seq(from = -3, to = 3, by = 0.01))
plot(dnorm(seq(from = -3, to = 3, by = 0.01)))
d <- dnorm(seq(from = -3, to = 3, by = 0.01))
plot(d)
library(quantmod)
plot(apply(p, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(r, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
plot(apply(r, MARGIN = 1, FUN = var), type = 'l')
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
plot(apply(r, MARGIN = 1, FUN = var), type = 'l')
hist(apply(p, MARGIN = 1, FUN = mean))
plot(apply(r, MARGIN = 1, FUN = var), type = 'l')
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
plot(apply(r, MARGIN = 1, FUN = var), type = 'l')
plot(apply(r, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(p, MARGIN = 1, FUN = mean), type = 'l')
abline(0,36)
abline(5,36)
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
abline(,36)
abline(0,36)
abline(0,36, col = 'r')
abline(0,36, col = 'red')
.libPaths()
install.packages("ggplot2")
install.packages("rlang")
library(rlang)
install.packages("skedastic")
install.packages("skedastic")
install.packages("skedastic")
# Generate sample data with two independent variables
set.seed(123)
x1 <- 1:100
x2 <- 50:149
y <- 2 * x1 - 2 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
# Perform linear regression with two independent variables
model <- lm(y ~ x1 + x2)
summary(model)
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = -x2"))  # Test if coefficients of x1 and x2 have this relationship
library(car)
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = -x2"))  # Test if coefficients of x1 and x2 have this relationship
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = x2"))  # Test if coefficients of x1 and x2 have this relationship
y <- 2 * x1 - 1 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
# Perform linear regression with two independent variables
model <- lm(y ~ x1 + x2)
summary(model)
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = x2"))  # Test if coefficients of x1 and x2 have this relationship
x1 <- 1:100
x2 <- 1:100
y <- 2 * x1 - 1 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
# Perform linear regression with two independent variables
model <- lm(y ~ x1 + x2)
summary(model)
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = x2"))  # Test if coefficients of x1 and x2 have this relationship
alias( lm( y ~ x1 + x2 ) )
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = x2"), singular.ok = TRUE)  # Test if coefficients of x1 and x2 have this relationship
y <- 2 * x1 - 2 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
x2 <- 5:149
y <- 2 * x1 - 2 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
x2 <- 50:149
y <- 2 * x1 - 2 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
# Perform linear regression with two independent variables
model <- lm(y ~ x1 + x2)
summary(model)
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = x2"), singular.ok = TRUE)  # Test if coefficients of x1 and x2 have this relationship
test_result
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 = x2", singular.ok = TRUE)  # Test if coefficients of x1 and x2 have this relationship
summary(model)
x1 <- 1:100
x2 <- 50:149
# Perform linear regression with two independent variables
model <- lm(y ~ x1 + x2)
summary(model)
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 = x2", singular.ok = TRUE)  # Test if coefficients of x1 and x2 have this relationship
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 + x2 =0", singular.ok = TRUE)  # Test if coefficients of x1 and x2 have this relationship
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 + x2 =0")  # Test if coefficients of x1 and x2 have this relationship
x1 <- rnorm(100,50,10)
x1 <- rnorm(100,50,10)
y <- 2 * x1 - 2 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
# Perform linear regression with two independent variables
model <- lm(y ~ x1 + x2)
summary(model)
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 + x2 =0")  # Test if coefficients of x1 and x2 have this relationship
test_result
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 = x2")  # Test if coefficients of x1 and x2 have this relationship
test_result
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 = -x2")  # Test if coefficients of x1 and x2 have this relationship
test_result
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 + x2 =0")  # Test if coefficients of x1 and x2 have this relationship
test_result
# First, suppress warnings, because there's a lot of them, mostly unimportant. Generally, you should be careful when
# suppressing warnings.
options(warn = -1)
# Import base packages.
library(methods)
# Import third-party packages.
library(PortfolioAnalytics)
library(quadprog)
library(quantmod)
library(ROI)
library(ROI.plugin.glpk)
install.packages("ROI.plugin.glpk")
install.packages("ROI.plugin.quadprog")
library(ROI.plugin.glpk)
library(ROI.plugin.quadprog)
# Help for getSymbols.
?getSymbols()
getSymbols(
"^GSPC",
src = "yahoo",
from = as.Date("2007-01-04"),
to = as.Date("2010-01-01"),
warnings = FALSE,
)
head(GSPC)
summary(GSPC$GSPC.Adjusted)
plot(y = GSPC$GSPC.Adjusted, x = index(GSPC), type = 'l')
head(AAPL, 125)
getSymbols(
"^AAPL",
src = "yahoo",
from = as.Date("2007-01-04"),
to = as.Date("2010-01-01"),
warnings = FALSE,
)
getSymbols(
"^AAPL",
src = "yahoo",
from = as.Date("2007-01-04"),
to = as.Date("2010-01-01"),
warnings = FALSE,
)
r.version()
R.Version()
R.Version()
R.Version()
R.Version()
R.version
install.packages("installr")
library(installr)
uprateR()
updateR()
R.version
updateR()
library(graphics)
library(RColorBrewer)
library(ggplot2)
library(tseries)
library(dplyr)
library(aod)
library(stargazer)
library(xtable)
library(stats)
library(zoo)
library(forecast)
library(rugarch)
library(xts)
library(highfrequency)
stocks$stockn
stocks$w_l
for(filename in setdiff(list.files("Data"), list.dirs("Data", recursive = FALSE, full.names = FALSE))){
load(paste("Data/", filename, sep = ""))
}
for(filename in setdiff(list.files("Data"), list.dirs("Data", recursive = FALSE, full.names = FALSE))){
load(paste("Data/", filename, sep = ""))
}
load("Data/RGARCH.RData")
setwd("F:/IES/BachelorThesis/Folder/BachelorThesis")
for(filename in setdiff(list.files("Data"), list.dirs("Data", recursive = FALSE, full.names = FALSE))){
load(paste("Data/", filename, sep = ""))
}
stocks
min(stocks$n_for)
for(stockn in stocks$stockname){
w_l = stocks$w_l[which(stocks$stockname == stockn)]    # TODO set better numbers
#  n_for = stocks$n_for[which(stocks$stockname == stockn)] # TODO set better numbers
n_for = 66
print(paste("ARMA-GARCH ",counter, ": ", stockn, sep = ""))
print("   Rolling")
# ARMA-GARCH
# rolling
ARMAGARCH_fc_r[[stockn]] <- ugarchroll(ARMAGARCH, 100*allstocks[[stockn]]$ret[1:(w_l+n_for+1),], n.ahead = 1, forecast.length = n_for,
n.start = NULL, refit.every = 1, refit.window = c("moving"),
window.size = w_l, solver = "hybrid", fit.control = list(),
solver.control = list(), calculate.VaR = FALSE,
keep.coef = TRUE,realizedVol = 100*(allstocks[[stockn]]$RV[1:(w_l+n_for+1),]))   # TODO: why is RV here?
ARMAGARCH_fc_r[[stockn]] <- xts(ARMAGARCH_fc_r[[stockn]]@forecast[["density"]]$Sigma,
order.by = as.Date(rownames(ARMAGARCH_fc_r[[stockn]]@forecast[["density"]])))/100
# expanding
#  print("   Expanding")
#  ARMAGARCH_fc_e[[stockn]] <- ugarchroll(ARMAGARCH, 100*allstocks[[stockn]]$ret[1:(w_l+n_for+1),], n.ahead = 1, forecast.length = n_for,
#                                         n.start = NULL, refit.every = 1, refit.window = c("recursive"),
#                                         window.size = w_l, solver = "hybrid", fit.control = list(),
#                                         solver.control = list(), calculate.VaR = FALSE,
#                                         keep.coef = TRUE,realizedVol = 100*(allstocks[[stockn]]$RV[1:(w_l+n_for+1),]))    # TODO: why is RV here?
#  ARMAGARCH_fc_e[[stockn]]<- xts(ARMAGARCH_fc_e[[stockn]]@forecast[["density"]]$Sigma,
#                       order.by = as.Date(rownames(ARMAGARCH_fc_e[[stockn]]@forecast[["density"]])))/100
#
#  counter = counter + 1
}
# Runs TODO
start_time = Sys.time()
counter = 1
for(stockn in stocks$stockname){
w_l = stocks$w_l[which(stocks$stockname == stockn)]    # TODO set better numbers
#  n_for = stocks$n_for[which(stocks$stockname == stockn)] # TODO set better numbers
n_for = 66
print(paste("ARMA-GARCH ",counter, ": ", stockn, sep = ""))
print("   Rolling")
# ARMA-GARCH
# rolling
ARMAGARCH_fc_r[[stockn]] <- ugarchroll(ARMAGARCH, 100*allstocks[[stockn]]$ret[1:(w_l+n_for+1),], n.ahead = 1, forecast.length = n_for,
n.start = NULL, refit.every = 1, refit.window = c("moving"),
window.size = w_l, solver = "hybrid", fit.control = list(),
solver.control = list(), calculate.VaR = FALSE,
keep.coef = TRUE,realizedVol = 100*(allstocks[[stockn]]$RV[1:(w_l+n_for+1),]))   # TODO: why is RV here?
ARMAGARCH_fc_r[[stockn]] <- xts(ARMAGARCH_fc_r[[stockn]]@forecast[["density"]]$Sigma,
order.by = as.Date(rownames(ARMAGARCH_fc_r[[stockn]]@forecast[["density"]])))/100
# expanding
#  print("   Expanding")
#  ARMAGARCH_fc_e[[stockn]] <- ugarchroll(ARMAGARCH, 100*allstocks[[stockn]]$ret[1:(w_l+n_for+1),], n.ahead = 1, forecast.length = n_for,
#                                         n.start = NULL, refit.every = 1, refit.window = c("recursive"),
#                                         window.size = w_l, solver = "hybrid", fit.control = list(),
#                                         solver.control = list(), calculate.VaR = FALSE,
#                                         keep.coef = TRUE,realizedVol = 100*(allstocks[[stockn]]$RV[1:(w_l+n_for+1),]))    # TODO: why is RV here?
#  ARMAGARCH_fc_e[[stockn]]<- xts(ARMAGARCH_fc_e[[stockn]]@forecast[["density"]]$Sigma,
#                       order.by = as.Date(rownames(ARMAGARCH_fc_e[[stockn]]@forecast[["density"]])))/100
#
#  counter = counter + 1
}
