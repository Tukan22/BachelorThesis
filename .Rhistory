for(i in 2:length){
p[i,] = p[i-1,] + eps[i,] + eps[i-1,]
e[i,] = -e[i-1,] + nu[i,]
r[i,] = r[i-1,] + e[i,]
}
length = 20
realisations = 10
p <- data.frame(matrix(ncol = realisations, nrow = length))
r <- data.frame(matrix(ncol = realisations, nrow = length))
e <- data.frame(matrix(ncol = realisations, nrow = length))
p[1,] = p_0
r[1,] = r_0
eps = data.frame(matrix(rnorm(length*realisations, mean_eps, std_eps), ncol = realisations, nrow = length))
eps[1,] = eps_0
nu = matrix(rnorm(length*realisations, mean_nu, std_nu), ncol = realisations, nrow = length)
nu[1,] = nu_0
e <- matrix(rep(0, times = realisations*length), ncol = realisations, nrow = length)
# IT SHOULD BE POSSIBLE TO VECTORIZE THIS! - OPTIMIZATION !
#  (Create a dataframe of errors instead of a vector for each realization)
for(i in 2:length){
p[i,] = p[i-1,] + eps[i,] + eps[i-1,]
e[i,] = -e[i-1,] + nu[i,]
r[i,] = r[i-1,] + e[i,]
}
plot.ts(p[,1], ylim = c(min(p),max(p)))
for(j in 2:realisations){
lines(p[,j], col = colors()[j])
}
plot.ts(r[,1], ylim = c(min(r),max(r)))
for(j in 2:realisations){
lines(r[,j], col = colors()[j])
}
length = 500
realisations = 1000
p <- data.frame(matrix(ncol = realisations, nrow = length))
r <- data.frame(matrix(ncol = realisations, nrow = length))
e <- data.frame(matrix(ncol = realisations, nrow = length))
length = 500
realisations = 100
p <- data.frame(matrix(ncol = realisations, nrow = length))
r <- data.frame(matrix(ncol = realisations, nrow = length))
e <- data.frame(matrix(ncol = realisations, nrow = length))
p[1,] = p_0
r[1,] = r_0
eps = data.frame(matrix(rnorm(length*realisations, mean_eps, std_eps), ncol = realisations, nrow = length))
eps[1,] = eps_0
nu = matrix(rnorm(length*realisations, mean_nu, std_nu), ncol = realisations, nrow = length)
nu[1,] = nu_0
e <- matrix(rep(0, times = realisations*length), ncol = realisations, nrow = length)
#library(data.table)
#p[-1,] = matrix(unlist(shift(p, 1L, type = "lag")), ncol = realisations, nrow = length)[-1,]
#head(eps)[-1,1:2]
#head(matrix(unlist(shift(eps, 1L, type = "lag")), ncol = realisations, nrow = length))[-1,1:2]
# IT SHOULD BE POSSIBLE TO VECTORIZE THIS! - OPTIMIZATION !
#  (Create a dataframe of errors instead of a vector for each realization)
for(i in 2:length){
p[i,] = p[i-1,] + eps[i,] + eps[i-1,]
e[i,] = -e[i-1,] + nu[i,]
r[i,] = r[i-1,] + e[i,]
}
plot.ts(p[,1], ylim = c(min(p),max(p)))
for(j in 2:realisations){
lines(p[,j], col = colors()[j])
}
plot.ts(r[,1], ylim = c(min(r),max(r)))
for(j in 2:realisations){
lines(r[,j], col = colors()[j])
}
diff(r)
head(r)
head(r[,1])
r[200:205,1]
diff(r[,1])
plot(diff(r[,1]), type = 'l')
plot(abs(diff(r[,1]), type = 'l'))
plot(abs(diff(r[,1]), type = 'l'))
plot(abs(diff(r[,1])), type = 'l')
for(i in 2:length){
p[i,] = p[i-1,] + eps[i,] + eps[i-1,]
e[i,] = -e[i-1,] + nu[i,]
r[i,] = 0.5*r[i-1,] + e[i,]
}
plot.ts(p[,1], ylim = c(min(p),max(p)))
for(j in 2:realisations){
lines(p[,j], col = colors()[j])
}
plot.ts(r[,1], ylim = c(min(r),max(r)))
for(j in 2:realisations){
lines(r[,j], col = colors()[j])
}
plot(abs(diff(r[,1])), type = 'l')
diff(r[,1]))
diff(r[,1])
diff(r[,1])<0
plot.ts(r[,1], ylim = c(min(r),max(r)))
for(j in 2:realisations){
lines(r[,j], col = colors()[j])
}
p_0 = 10
r_0 = 10
eps_0 = 0
nu_0 = 0
e_0 = 0
length = 500
realisations = 100
p <- data.frame(matrix(ncol = realisations, nrow = length))
r <- data.frame(matrix(ncol = realisations, nrow = length))
e <- data.frame(matrix(ncol = realisations, nrow = length))
p[1,] = p_0
r[1,] = r_0
eps = data.frame(matrix(rnorm(length*realisations, mean_eps, std_eps), ncol = realisations, nrow = length))
eps[1,] = eps_0
nu = matrix(rnorm(length*realisations, mean_nu, std_nu), ncol = realisations, nrow = length)
nu[1,] = nu_0
e <- matrix(rep(0, times = realisations*length), ncol = realisations, nrow = length)
# IT SHOULD BE POSSIBLE TO VECTORIZE THIS! - OPTIMIZATION !
#  (Create a dataframe of errors instead of a vector for each realization)
for(i in 2:length){
p[i,] = p[i-1,] + eps[i,] + eps[i-1,]
e[i,] = -e[i-1,] + nu[i,]
r[i,] = r[i-1,] + e[i,]
}
plot.ts(p[,1], ylim = c(min(p),max(p)))
for(j in 2:realisations){
lines(p[,j], col = colors()[j])
}
plot.ts(r[,1], ylim = c(min(r),max(r)))
for(j in 2:realisations){
lines(r[,j], col = colors()[j])
}
plot(apply(p, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(r, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(p, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
plot(apply(r, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
plot(apply(r, MARGIN = 1, FUN = var), type = 'l')
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
max(apply(p, MARGIN = 1, FUN = var))
abline(1,2)
abline(2)
abline(36,0)
abline(36*500,0)
abline(,36)
abline(0,36)
library(moments)
install.packages("moments")
library(moments)
set.seed(1234)
kurtosis(rnorm(1000))
hist(apply(r, MARGIN = 1, FUN = mean))
hist(apply(r, MARGIN = 1, FUN = mean), density = T)
plot(seq(from = -3, to = 3, by = 0.01))
plot(dnorm(seq(from = -3, to = 3, by = 0.01)))
d <- dnorm(seq(from = -3, to = 3, by = 0.01))
plot(d)
library(quantmod)
plot(apply(p, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(r, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
plot(apply(r, MARGIN = 1, FUN = var), type = 'l')
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
plot(apply(r, MARGIN = 1, FUN = var), type = 'l')
hist(apply(p, MARGIN = 1, FUN = mean))
plot(apply(r, MARGIN = 1, FUN = var), type = 'l')
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
plot(apply(r, MARGIN = 1, FUN = var), type = 'l')
plot(apply(r, MARGIN = 1, FUN = mean), type = 'l')
plot(apply(p, MARGIN = 1, FUN = mean), type = 'l')
abline(0,36)
abline(5,36)
plot(apply(p, MARGIN = 1, FUN = var), type = 'l')
abline(,36)
abline(0,36)
abline(0,36, col = 'r')
abline(0,36, col = 'red')
.libPaths()
install.packages("ggplot2")
install.packages("rlang")
library(rlang)
install.packages("skedastic")
install.packages("skedastic")
install.packages("skedastic")
# Generate sample data with two independent variables
set.seed(123)
x1 <- 1:100
x2 <- 50:149
y <- 2 * x1 - 2 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
# Perform linear regression with two independent variables
model <- lm(y ~ x1 + x2)
summary(model)
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = -x2"))  # Test if coefficients of x1 and x2 have this relationship
library(car)
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = -x2"))  # Test if coefficients of x1 and x2 have this relationship
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = x2"))  # Test if coefficients of x1 and x2 have this relationship
y <- 2 * x1 - 1 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
# Perform linear regression with two independent variables
model <- lm(y ~ x1 + x2)
summary(model)
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = x2"))  # Test if coefficients of x1 and x2 have this relationship
x1 <- 1:100
x2 <- 1:100
y <- 2 * x1 - 1 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
# Perform linear regression with two independent variables
model <- lm(y ~ x1 + x2)
summary(model)
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = x2"))  # Test if coefficients of x1 and x2 have this relationship
alias( lm( y ~ x1 + x2 ) )
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = x2"), singular.ok = TRUE)  # Test if coefficients of x1 and x2 have this relationship
y <- 2 * x1 - 2 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
x2 <- 5:149
y <- 2 * x1 - 2 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
x2 <- 50:149
y <- 2 * x1 - 2 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
# Perform linear regression with two independent variables
model <- lm(y ~ x1 + x2)
summary(model)
# Test if coefficients are equal
test_result <- linearHypothesis(model, c("x1 = x2"), singular.ok = TRUE)  # Test if coefficients of x1 and x2 have this relationship
test_result
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 = x2", singular.ok = TRUE)  # Test if coefficients of x1 and x2 have this relationship
summary(model)
x1 <- 1:100
x2 <- 50:149
# Perform linear regression with two independent variables
model <- lm(y ~ x1 + x2)
summary(model)
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 = x2", singular.ok = TRUE)  # Test if coefficients of x1 and x2 have this relationship
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 + x2 =0", singular.ok = TRUE)  # Test if coefficients of x1 and x2 have this relationship
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 + x2 =0")  # Test if coefficients of x1 and x2 have this relationship
x1 <- rnorm(100,50,10)
x1 <- rnorm(100,50,10)
y <- 2 * x1 - 2 * x2 + 5 + rnorm(100, mean = 0, sd = 10)  # Generating y with some noise
# Perform linear regression with two independent variables
model <- lm(y ~ x1 + x2)
summary(model)
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 + x2 =0")  # Test if coefficients of x1 and x2 have this relationship
test_result
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 = x2")  # Test if coefficients of x1 and x2 have this relationship
test_result
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 = -x2")  # Test if coefficients of x1 and x2 have this relationship
test_result
# Test if coefficients are equal
test_result <- linearHypothesis(model, "x1 + x2 =0")  # Test if coefficients of x1 and x2 have this relationship
test_result
# First, suppress warnings, because there's a lot of them, mostly unimportant. Generally, you should be careful when
# suppressing warnings.
options(warn = -1)
# Import base packages.
library(methods)
# Import third-party packages.
library(PortfolioAnalytics)
library(quadprog)
library(quantmod)
library(ROI)
library(ROI.plugin.glpk)
install.packages("ROI.plugin.glpk")
install.packages("ROI.plugin.quadprog")
library(ROI.plugin.glpk)
library(ROI.plugin.quadprog)
# Help for getSymbols.
?getSymbols()
getSymbols(
"^GSPC",
src = "yahoo",
from = as.Date("2007-01-04"),
to = as.Date("2010-01-01"),
warnings = FALSE,
)
head(GSPC)
summary(GSPC$GSPC.Adjusted)
plot(y = GSPC$GSPC.Adjusted, x = index(GSPC), type = 'l')
head(AAPL, 125)
getSymbols(
"^AAPL",
src = "yahoo",
from = as.Date("2007-01-04"),
to = as.Date("2010-01-01"),
warnings = FALSE,
)
getSymbols(
"^AAPL",
src = "yahoo",
from = as.Date("2007-01-04"),
to = as.Date("2010-01-01"),
warnings = FALSE,
)
r.version()
R.Version()
R.Version()
R.Version()
R.Version()
R.version
install.packages("installr")
library(installr)
uprateR()
updateR()
R.version
updateR()
library(arrow)
library(xts)
library(graphics)
library(RColorBrewer)
library(ggplot2)
library(tseries)
library(dplyr)
library(aod)
library(stargazer)
library(xtable)
library(stats)
library(zoo)
library(forecast)
library(rugarch)
library(xts)
library(highfrequency)
library(fitdistrplus)
library(MASS)
library(mosaic)
library(segMGarch)
library(GAS)
for(filename in setdiff(list.files("Data"), list.dirs("Data", recursive = FALSE, full.names = FALSE))){
load(paste("Data/", filename, sep = ""))
}
setwd("F:/IES/BachelorThesis/Folder/BachelorThesis")
for(filename in setdiff(list.files("Data"), list.dirs("Data", recursive = FALSE, full.names = FALSE))){
load(paste("Data/", filename, sep = ""))
}
for(stockn in stocks$stockname){
w_l = stocks$w_l[which(stocks$stockname == stockn)]    # TODO set better numbers
n_for = stocks$n_for[which(stocks$stockname == stockn)] # TODO set better numbers
print(paste("RGARCH ",counter, ": ", stockn, sep = ""))
print("   Rolling")
# RGARCH
# rolling
RGARCH_fc_r[[stockn]] <- ugarchroll(RGARCH, 100*allstocks[[stockn]]$ret[1:(w_l+n_for+1),], n.ahead = 1, forecast.length = n_for,
n.start = NULL, refit.every = 1, refit.window = c("moving"), window.size = w_l,
solver = "hybrid", calculate.VaR = FALSE,keep.coef = TRUE,realizedVol = (100*sqrt(allstocks[[stockn]]$RV[1:(w_l+n_for+1),])))
RGARCH_fc_r[[stockn]] <- xts(RGARCH_fc_r[[stockn]]@forecast[["density"]]$Sigma,
order.by = as.Date(rownames(RGARCH_fc_r[[stockn]]@forecast[["density"]])))/100
# expanding
print("   Expanding")
RGARCH_fc_e[[stockn]] <- ugarchroll(RGARCH, 100*allstocks[[stockn]]$ret[1:(w_l+n_for+1),], n.ahead = 1, forecast.length = n_for,
n.start = NULL, refit.every = 1, refit.window = c("recursive"),
window.size = w_l, solver = "hybrid", calculate.VaR = FALSE,
keep.coef = TRUE,realizedVol = 100*sqrt((allstocks[[stockn]]$RV[1:(w_l+n_for+1),])))
RGARCH_fc_e[[stockn]]<- xts(RGARCH_fc_e[[stockn]]@forecast[["density"]]$Sigma,
order.by = as.Date(rownames(RGARCH_fc_e[[stockn]]@forecast[["density"]])))/100
counter = counter + 1
}
start_time2 = Sys.time()
counter = 1
for(stockn in stocks$stockname){
w_l = stocks$w_l[which(stocks$stockname == stockn)]    # TODO set better numbers
n_for = stocks$n_for[which(stocks$stockname == stockn)] # TODO set better numbers
print(paste("RGARCH ",counter, ": ", stockn, sep = ""))
print("   Rolling")
# RGARCH
# rolling
RGARCH_fc_r[[stockn]] <- ugarchroll(RGARCH, 100*allstocks[[stockn]]$ret[1:(w_l+n_for+1),], n.ahead = 1, forecast.length = n_for,
n.start = NULL, refit.every = 1, refit.window = c("moving"), window.size = w_l,
solver = "hybrid", calculate.VaR = FALSE,keep.coef = TRUE,realizedVol = (100*sqrt(allstocks[[stockn]]$RV[1:(w_l+n_for+1),])))
RGARCH_fc_r[[stockn]] <- xts(RGARCH_fc_r[[stockn]]@forecast[["density"]]$Sigma,
order.by = as.Date(rownames(RGARCH_fc_r[[stockn]]@forecast[["density"]])))/100
# expanding
print("   Expanding")
RGARCH_fc_e[[stockn]] <- ugarchroll(RGARCH, 100*allstocks[[stockn]]$ret[1:(w_l+n_for+1),], n.ahead = 1, forecast.length = n_for,
n.start = NULL, refit.every = 1, refit.window = c("recursive"),
window.size = w_l, solver = "hybrid", calculate.VaR = FALSE,
keep.coef = TRUE,realizedVol = 100*sqrt((allstocks[[stockn]]$RV[1:(w_l+n_for+1),])))
RGARCH_fc_e[[stockn]]<- xts(RGARCH_fc_e[[stockn]]@forecast[["density"]]$Sigma,
order.by = as.Date(rownames(RGARCH_fc_e[[stockn]]@forecast[["density"]])))/100
counter = counter + 1
}
for(stockn in stocks$stockname){
print(paste(counter, " - ", stockn ,sep=""))
retstouse = allstocks[[stockn]]$ret[
min(which(index(allstocks[[stockn]])>=as.Date(forecast_start_date))+1):
min(which(index(allstocks[[stockn]])>=(as.Date(forecast_start_date)))+n_for)]
x=as.xts(allstocks[[stockn]]$ret)
fit.t = fitdistr(
x = x*1000,
densfun = "t",
start = list(m=mean(x),s=sd(x), df=stocks$t_df_start[which(stocks$stockname == stockn)]),
lower=c(-1, 0.001,0.01))$estimate/c(1000,1000,1)
fit.df = fit.t[3]
# Check how the VaR should be calculated
VaR95_AR1_RV_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (AR1_RV_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_AR1_RV_r[[stockn]] =as.xts(mean(allstocks[[stockn]]$ret) + (AR1_RV_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_r[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_AS_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_AS_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_AS_r[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_AS_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_RS_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_RS_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_RS_r[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_RS_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_RSRK_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_RSRK_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_RSRK_r[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_RSRK_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_RGARCH_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (RGARCH_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_RGARCH_r[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (RGARCH_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_ARMAGARCH_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (ARMAGARCH_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_ARMAGARCH_r[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (ARMAGARCH_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
Backtests_AR1_RV_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_AR1_RV_e[[stockn]], alpha = 0.05)
Backtests_AR1_RV_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_AR1_RV_r[[stockn]], alpha = 0.05)
Backtests_HAR_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_e[[stockn]], alpha = 0.05)
Backtests_HAR_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_r[[stockn]], alpha = 0.05)
Backtests_HAR_AS_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_AS_e[[stockn]], alpha = 0.05)
Backtests_HAR_AS_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_AS_r[[stockn]], alpha = 0.05)
Backtests_HAR_RS_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_RS_e[[stockn]], alpha = 0.05)
Backtests_HAR_RS_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_RS_r[[stockn]], alpha = 0.05)
Backtests_HAR_RSRK_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_RSRK_e[[stockn]], alpha = 0.05)
Backtests_HAR_RSRK_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_RSRK_r[[stockn]], alpha = 0.05)
Backtests_RGARCH_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_RGARCH_e[[stockn]], alpha = 0.05)
Backtests_RGARCH_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_RGARCH_r[[stockn]], alpha = 0.05)
Backtests_ARMAGARCH_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_ARMAGARCH_e[[stockn]], alpha = 0.05)
Backtests_ARMAGARCH_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_ARMAGARCH_r[[stockn]], alpha = 0.05)
counter = counter + 1
}
start_time = Sys.time()
counter = 1
for(stockn in stocks$stockname){
print(paste(counter, " - ", stockn ,sep=""))
retstouse = allstocks[[stockn]]$ret[
min(which(index(allstocks[[stockn]])>=as.Date(forecast_start_date))+1):
min(which(index(allstocks[[stockn]])>=(as.Date(forecast_start_date)))+n_for)]
x=as.xts(allstocks[[stockn]]$ret)
fit.t = fitdistr(
x = x*1000,
densfun = "t",
start = list(m=mean(x),s=sd(x), df=stocks$t_df_start[which(stocks$stockname == stockn)]),
lower=c(-1, 0.001,0.01))$estimate/c(1000,1000,1)
fit.df = fit.t[3]
# Check how the VaR should be calculated
VaR95_AR1_RV_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (AR1_RV_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_AR1_RV_r[[stockn]] =as.xts(mean(allstocks[[stockn]]$ret) + (AR1_RV_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_r[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_AS_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_AS_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_AS_r[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_AS_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_RS_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_RS_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_RS_r[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_RS_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_RSRK_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_RSRK_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_HAR_RSRK_r[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (HAR_RSRK_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_RGARCH_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (RGARCH_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_RGARCH_r[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (RGARCH_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_ARMAGARCH_e[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (ARMAGARCH_fc_e[[stockn]])*qt(p = 0.05, df = fit.df))
VaR95_ARMAGARCH_r[[stockn]] = as.xts(mean(allstocks[[stockn]]$ret) + (ARMAGARCH_fc_r[[stockn]])*qt(p = 0.05, df = fit.df))
Backtests_AR1_RV_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_AR1_RV_e[[stockn]], alpha = 0.05)
Backtests_AR1_RV_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_AR1_RV_r[[stockn]], alpha = 0.05)
Backtests_HAR_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_e[[stockn]], alpha = 0.05)
Backtests_HAR_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_r[[stockn]], alpha = 0.05)
Backtests_HAR_AS_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_AS_e[[stockn]], alpha = 0.05)
Backtests_HAR_AS_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_AS_r[[stockn]], alpha = 0.05)
Backtests_HAR_RS_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_RS_e[[stockn]], alpha = 0.05)
Backtests_HAR_RS_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_RS_r[[stockn]], alpha = 0.05)
Backtests_HAR_RSRK_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_RSRK_e[[stockn]], alpha = 0.05)
Backtests_HAR_RSRK_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_HAR_RSRK_r[[stockn]], alpha = 0.05)
Backtests_RGARCH_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_RGARCH_e[[stockn]], alpha = 0.05)
Backtests_RGARCH_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_RGARCH_r[[stockn]], alpha = 0.05)
Backtests_ARMAGARCH_e[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_ARMAGARCH_e[[stockn]], alpha = 0.05)
Backtests_ARMAGARCH_r[[stockn]] = BacktestVaR(data = retstouse, VaR = VaR95_ARMAGARCH_r[[stockn]], alpha = 0.05)
counter = counter + 1
}
end_time = Sys.time()
print(end_time-start_time)
stockn = "AAL"
unname(Backtests_RGARCH_e[[stockn]]$LRuc[2])
unname(Backtests_RGARCH_r[[stockn]]$LRuc[2])
stockn = "AAPL"
unname(Backtests_RGARCH_e[[stockn]]$LRuc[2])
unname(Backtests_RGARCH_r[[stockn]]$LRuc[2])
stockn = "XOM"
unname(Backtests_RGARCH_e[[stockn]]$LRuc[2])
unname(Backtests_RGARCH_r[[stockn]]$LRuc[2])
lapply(allstocks, function(x) {x$RV == x$RVp + x$RVm})
lapply(allstocks, function(x) {x$RV})
lapply(allstocks, function(x) {$RVp + x$RVm})
lapply(allstocks, function(x) {x$RVp + x$RVm})
lapply(allstocks, function(x) {x$RSp + x$RSm})
lapply(allstocks, function(x) {x$RV == x$RSp + x$RSm})
lapply(allstocks, function(x) {x$RV - x$RSp + x$RSm})
lapply(allstocks, function(x) {mean(x$RV - x$RSp + x$RSm)})
allstocks[["AAL"]]$RV
allstocks[["AAL"]]$RSp
sqrt(allstocks[["AAL"]]$RSp)
allstocks[["AAL"]]$RSp
allstocks[["AAL"]]$RSp + allstocks[["AAL"]]$RSm
allstocks[["AAL"]]$RV
allstocks[["AAL"]]$RSp + allstocks[["AAL"]]$RSm
allstocks[["AAL"]]$RV
allstocks[["AAL"]]$RSp + allstocks[["AAL"]]$RSm == allstocks[["AAL"]]$RV
allstocks[["AAL"]]$RV
allstocks[["AAL"]]$RSp + allstocks[["AAL"]]$RSm
allstocks[["AAL"]]$RSp + allstocks[["AAL"]]$RSm - allstocks[["AAL"]]$RV
mean(allstocks[["AAL"]]$RSp + allstocks[["AAL"]]$RSm - allstocks[["AAL"]]$RV )
lapply(allstocks, function(x) {mean(x$RV - x$RSp + x$RSm)})
mean(allstocks[["AAL"]]$RSp + allstocks[["AAL"]]$RSm - allstocks[["AAL"]]$RV )
lapply(allstocks, function(x) {mean(x$RV - x$RSp + x$RSm)})
mean(allstocks[["XOM"]]$RSp + allstocks[["AAL"]]$RSm - allstocks[["AAL"]]$RV )
mean(allstocks[["AAL"]]$RSp + allstocks[["AAL"]]$RSm - allstocks[["AAL"]]$RV )
lapply(allstocks, function(x) {mean(x$RV - x$RSp + x$RSm)})
